# -----------------------------------------------------------------------------
# Author    : Albert Akhriev, albert_akhriev@ie.ibm.com
# Copyright : IBM Research Ireland, 2017-2018
# -----------------------------------------------------------------------------

#import pdb; pdb.set_trace()           # enables debugging
import matplotlib
matplotlib.use("Agg")
import sys, traceback, os, re, getopt, math, argparse, subprocess
import numpy as np
import scipy
import scipy.misc
import scipy.sparse
import scipy.sparse.linalg
from timeit import default_timer as timer
from Configuration import Configuration
from Utility import *

# Full-path name of C++ executable.
AMDADOS_EXE = "build/app/amdados"


def Amdados2D(config_file, demo):
    """ Advection-diffusion PDE forward solver.
    """
    # Initialize parameters, global indices and output directory.
    conf = Configuration(config_file)
    conf = InitDependentParams(conf)
    glo_idx = GlobalIndices(conf)
    if demo: conf.PrintParameters()
    MakePath(conf.output_dir + os.sep)

    # Load sensor locations previously generated by C++ 'amdados' application:
    #   './build/app/amdados --scenario sensors'
    # If does not exist, the file of sensor locations will be regenerated.
    sensors_filename = MakeFileName(conf, "sensors")
    if not os.path.exists(sensors_filename):
        print("")
        print("")
        print("WARNING: missed file of sensor locations: " + sensors_filename)
        print("generating a new one ...")
        assert os.path.exists(AMDADOS_EXE), (
            "Application 'amdados' must be built before running this script")
        subprocess.run([AMDADOS_EXE, "--scenario", "sensors",
                        "--config", config_file], check=True)
        subprocess.run("sync", check=True)
        print("")
        print("")
    sensor_idx = LoadSensorLocations(conf)

    # Run forward simulation and record the "true" solutions into a file.
    with open(MakeFileName(conf, "true_field"), "wb") as fid:
        ForwardSolver(conf, glo_idx, sensor_idx, fid, demo)


###############################################################################
# Initialization.
###############################################################################

def InitDependentParams(conf):
    """ Function initializes dependent parameters given
        the primary ones specified by user.
    """
    # Ensure integer values.
    conf.nx = round(conf.num_subdomains_x * conf.subdomain_x)
    conf.ny = round(conf.num_subdomains_y * conf.subdomain_y)
    conf.integration_nsteps = round(conf.integration_nsteps)

    # Diffusion coefficient must be positive float value.
    D = float(conf.diffusion_coef)
    assert D > 0

    # Deduce space discretization steps.
    conf.problem_size = int(conf.nx * conf.ny)
    dx = float(conf.domain_size_x) / float(conf.nx-1)
    dy = float(conf.domain_size_y) / float(conf.ny-1)
    assert (dx > 0) and (dy > 0)
    conf.dx = dx
    conf.dy = dy

    # Deduce the optimal time step from the stability criteria.
    tiny = np.finfo(float).tiny / np.finfo(float).eps**3
    dt_base = float(conf.integration_period) / float(conf.integration_nsteps)
    max_vx = float(conf.flow_model_max_vx)
    max_vy = float(conf.flow_model_max_vy)
    dt = min(dt_base, min( min(dx**2, dy**2)/(2.0*D + tiny),
                           1.0/(abs(max_vx)/dx + abs(max_vy)/dy + tiny) ))
    assert(dt > 0)
    conf.dt = dt
    conf.Nt = round(math.ceil(float(conf.integration_period) / dt))

    # Compute coefficients that will be used in the finite-difference scheme.
    conf.rho_x = float(D * dt / dx**2)
    conf.rho_y = float(D * dt / dy**2)

    conf.v0x = float(2.0 * dx / dt)
    conf.v0y = float(2.0 * dy / dt)
    return conf


def GlobalIndices(conf):
    """ Each nodal point gets a unique global index on the grid.
        Function initializes a 2D array of indices:
            index of (x,y) = glo_idx(x,y).
    """
    glo_idx = np.arange(round(conf.problem_size)).reshape((conf.nx, conf.ny))
    return glo_idx


def LoadSensorLocations(conf):
    """ Function loads sensor locations, i.e. indices of domain
        points occupied by sensors.
    """
    print("Loading sensor locations ...")
    Nx = conf.nx
    Ny = conf.ny
    Np = round(math.ceil(Nx * Ny * conf.sensor_fraction))
    data = np.loadtxt(MakeFileName(conf, "sensors"), dtype=int)
    assert (data is not None) and (data.size > 0), "empty file of sensors"
    if data.ndim == 1:
        assert data.size == 2                   # single sensor point (x,y)
        data = np.reshape(data, (-1,data.size))
    assert len(data.shape) == 2 and data.shape[1] == 2, "wrong layout"
    assert data.shape[0] <= Nx * Ny, "too many records"
    assert data.dtype == int, "type mismatch"
    assert np.all(data >= 0), "negative index"
    assert np.all(data[:,0] < Nx), "x-index is out of bound"
    assert np.all(data[:,1] < Ny), "y-index is out of bound"
    return data

###############################################################################
# Advection-diffusion PDE stuff.
###############################################################################

def ApplyBoundaryCondition(conf, field):
    """ Function applies Dirichlet zero boundary condition to the state field.
    """
    assert field.shape[0] == conf.nx and field.shape[1] == conf.ny
    field[0,:] = 0
    field[:,0] = 0
    field[-1,:] = 0
    field[:,-1] = 0
    return field


def InverseModelMatrix(conf, glo_idx, discrete_time):
    """ Function initializes inverse matrix of implicit Euler time-integrator:
        B * x_{t+1} = x_{t}, where B = A^{-1} is the matrix returned by this
        function. The matrix must be inverted while iterating forward in time:
        x_{t+1} = A * x_{t}.
    """
    nx = conf.nx
    ny = conf.ny
    problem_size = conf.problem_size
    num_nz = 5 * nx * ny

    rows = np.zeros((num_nz,), dtype=int)
    cols = np.zeros((num_nz,), dtype=int)
    vals = np.zeros((num_nz,), dtype=float)

    vx, vy = Flow(conf, discrete_time)
    rho_x = conf.rho_x
    rho_y = conf.rho_y
    vx = vx / conf.v0x
    vy = vy / conf.v0y

    N = 0
    for x in range(nx):
        # Enforce von Newmann boundary condition (du/dn = 0).
        xm = x-1 if x > 0    else 1
        xp = x+1 if x < nx-1 else nx-2

        for y in range(ny):
            i = glo_idx[x,y]

            # Enforce von Newmann boundary condition (du/dn = 0).
            ym = y-1 if y > 0    else 1
            yp = y+1 if y < ny-1 else ny-2

            rows[N] = i;  cols[N] = i;              vals[N] = 1 + 2*(rho_x + rho_y);  N += 1
            rows[N] = i;  cols[N] = glo_idx[xm,y];  vals[N] = - vx - rho_x;           N += 1
            rows[N] = i;  cols[N] = glo_idx[xp,y];  vals[N] = + vx - rho_x;           N += 1
            rows[N] = i;  cols[N] = glo_idx[x,ym];  vals[N] = - vy - rho_y;           N += 1
            rows[N] = i;  cols[N] = glo_idx[x,yp];  vals[N] = + vy - rho_y;           N += 1

    assert N == num_nz
    invA = scipy.sparse.csr_matrix((vals, (rows, cols)),
                                    shape=(problem_size, problem_size))
    assert invA.nnz <= num_nz
    return invA


def Flow(conf, discrete_time):
    """ Function computes flow components given a time.
    """
    t = float(discrete_time) / float(conf.Nt)
    vx = -conf.flow_model_max_vx * math.sin(0.1 * t - math.pi)
    vy = -conf.flow_model_max_vy * math.sin(0.2 * t - math.pi)
    return vx, vy


def InitialField(conf):
    """ Create initial ("true") field with a bell-shaped spot around some point
        and zeros almost elsewhere. Note, the bell-shaped spot is sufficiently
        smooth to make the field differentiable.
    """
    nx = conf.nx
    ny = conf.ny
    field = np.zeros((nx, ny))
    sigma = int(1)                          # in logical units (point indices)
    cx = round(float(conf.spot_x) / conf.dx)
    cy = round(float(conf.spot_y) / conf.dy)
    a = float(conf.spot_density) / (float(sigma)**2 * 2.0 * math.pi)
    b = 1.0 / (2.0 * float(sigma)**2)

    for x in range(-4*sigma, 4*sigma+1):
        ix = min(max(x + cx, 0), nx-1)
        for y in range(-4*sigma, 4*sigma+1):
            iy = min(max(y + cy, 0), ny-1)
            field[ix,iy] += a * math.exp(-b * float(x*x + y*y))

    field = ApplyBoundaryCondition(conf, field)
    return field


def ForwardSolver(conf, glo_idx, sensor_idx, solution_fid, demo):
    """ Using model matrix A, the function integrates advection-diffusion
        equation forward in time (x_{t+1} = A * x_{t}) and generates a
        solution (state) field. This field is considered as the "true"
        state of nature and it serves as a source of the "true" observations.
        Observations at sensors locations are recorded every time step into
        a file. A number of entire fields are also recorded over the course
        of simulation.
    """
    start_time = timer()
    print("#################################################")
    print("Generating the observations by forward solver ...")
    print("#################################################")

    field = InitialField(conf)
    writer = Writer(conf)
    hFigure = None
    progress = PrintProgress(conf.Nt)
    Nt = round(conf.Nt)
    Nw = round(conf.write_num_fields)

    plt = None
    if demo: plt = SwitchToGraphicalBackend()

    # Time integration.
    for k in range(Nt):
        progress.Print(k)

        # Write the field entries at sensors into the file of observations.
        writer.WriteField(field, sensor_idx, k)
        # Write a number of full fields for comparison against C++ simulation.
        if k == 0 or ((Nw-1)*(k-1))//(Nt-1) != ((Nw-1)*k)//(Nt-1):
            WriteEntireField(solution_fid, field, k)

        # Visualization, if needed.
        if plt is not None:
            image = Field2Image(field)
            if hFigure is None:
                hFigure = plt.imshow(image)
            else:
                hFigure.set_data(image)
            plt.title("True field, t=" + str(k), fontsize=10, fontweight="bold")
            plt.pause(0.05)
            plt.draw()

        # Time marching of the forward solver.
        invA = InverseModelMatrix(conf, glo_idx, k)       # invA = A^{-1}
        fld1D = np.reshape(field, (conf.problem_size, 1)) # flatten the field
        field = scipy.sparse.linalg.spsolve(invA, fld1D)  # x_{t+1} = invA*x_t
        field = np.reshape(field, (conf.nx, conf.ny))     # back to 2D field
        field = ApplyBoundaryCondition(conf, field)       # boundary conditions

    progress.Finalize()
    del writer
    if plt is not None: plt.close()
    print("execution time: " + str(timer() - start_time) + " seconds\n\n")

###############################################################################
# Utilities.
###############################################################################

def WriteEntireField(fid, field, discrete_time):
    """ Function writes the entire field in binary file. This is different
        from saving values at sensor locations in the class Writer (see below),
        where saving is done on every time step.
    """
    THR = np.finfo(np.float32).max * np.float32(0.5)
    assert isinstance(discrete_time, int) and discrete_time >= 0
    assert np.isnan(field).any() == False, "NaN in solution field"
    assert np.all(np.fabs(field) < THR), "too big values for float32 format"
    nr = field.shape[0]
    nc = field.shape[1]
    ts   = np.full((nr*nc,1), np.float32(discrete_time), dtype=np.float32)
    rows = np.repeat(np.arange(nr), nc).astype(np.float32)
    cols = np.tile(np.arange(nc), nr).astype(np.float32)
    vals = field.flatten().astype(np.float32)
    data = np.column_stack((ts, rows, cols, vals))
    data.tofile(fid);
    fid.flush()


class Writer:
    """ Class for writing simulated solution at sensor locations in a text file.
    """
    def __init__(self, conf):
        """ Constructor. TODO: could be useful to add a header to file:
        """
        # N O T E: np.savetxt() expects (!?) file opened in binary format "wb".
        self.fid = open(MakeFileName(conf, "analytic"), "wb")

    def __del__(self):
        """ This method is not a destructor, but a normal method that is always
            called before the garbage collector destroys the object.
        https://stackoverflow.com/questions/37852560/is-del-really-a-destructor
        """
        if self.fid is not None:
            self.fid.flush()
            self.fid.close()
            self.fid = None

    def WriteField(self, field, sensor_idx, discrete_time):
        """ Function appends the new field to the output file.
            Only values at sensor locations are written.
            column 1: discrete time;
            column 2: sensor abscissas (point indices) on the grid;
            column 3: sensor ordinates (point indices) on the grid;
            column 4: values at sensor locations.
        """
        assert isinstance(discrete_time, int) and discrete_time >= 0
        assert len(sensor_idx.shape) == 2 and sensor_idx.shape[1] == 2

        xind = sensor_idx[:, 0].astype(int)
        yind = sensor_idx[:, 1].astype(int)
        vals = field[xind, yind].astype(float)
        assert np.isnan(vals).any() == False, "NaN in observations"
        vals[np.fabs(vals) <= np.finfo(np.float32).eps] = 0
        data = np.column_stack((xind, yind, vals))
        num = data.shape[0]
        np.savetxt(self.fid, np.array([discrete_time, num]), fmt="%d")
        np.savetxt(self.fid, data, fmt="%d %d %g");

###############################################################################
# Entry point.
###############################################################################
if __name__ == "__main__":
    try:
        CheckPythonVersion()
        parser = argparse.ArgumentParser()
        parser.add_argument("--config",
                            type=str, default="amdados.conf",
                            help="path to configuration file")
        parser.add_argument("--demo", nargs="?", const=True,
                            type=bool, default=False,
                            help="show live progress in a window")
        param = parser.parse_args()
        param.config = os.path.expanduser(param.config)
        print("Options:")
        print("Visualization: " + str(param.demo))
        print("Configuration files: " + param.config)
        print("")
        Amdados2D(param.config, param.demo)

    except subprocess.CalledProcessError as error:
        traceback.print_exc()
        if error.output is not None:
            print("ERROR: " + str(error.output))
        else:
            print("CalledProcessError")
    except AssertionError as error:
        traceback.print_exc()
        print("ERROR: " + str(error.args))
    except ValueError as error:
        traceback.print_exc()
        print("ERROR: " + str(error.args))
    except Exception as error:
        traceback.print_exc()
        print("ERROR: " + str(error.args))
