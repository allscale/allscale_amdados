# -----------------------------------------------------------------------------
# Author    : Albert Akhriev, albert_akhriev@ie.ibm.com
# Copyright : IBM Research Ireland, 2017
# -----------------------------------------------------------------------------

""" This script runs several simulations with increasing problem size.
    It saves the execution time of each simulation along with problem size,
    so one can plot the scalability profile.
    Each run is twofold. First, we run the Python simulator that generates
    the ground-truth and observations. The Python code itself can use the C++
    code running in the special mode for generating sensor locations (scenario
    "sensors"). Second, the C++ data assimilation application is run using
    the observations previously generated by the Python code (scenario
    "simulation").
    The results of all the simulations are accumulated in the output directory
    and can be later on be visualized using the script "Visualize.py".
    The configuration file "amdados.conf" is used in all the simulations with
    modification of three parameters: grid sizes in both dimensions and
    integration time. The other parameters remain intact. It is not recommended
    to tweak parameters unless you understand what are you doing. If you
    anyway modified the parameters, please, consider the results in the output
    directory as NOT valid any longer and rerun this script.
    The script was designed to fulfil the formal requirements of the Allscale
    project.
"""

#import pdb; pdb.set_trace()           # enables debugging
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import sys, traceback, os, glob, getopt, math, argparse, subprocess
import numpy as np
import numpy.linalg
import scipy
import scipy.misc
import scipy.sparse
import scipy.sparse.linalg
from timeit import default_timer as timer
from Configuration import Configuration
from ObservationsGenerator import InitDependentParams, Amdados2D
from Utility import *

# Grid sizes (number of subdomains in each direction) for scalability tests.
# This is a set of too big problems, especially for Python (~ few months):
#Resolutions = [(11,11), (23,25), (43,41), (83,89), (167,163), (367,373)]
# This is a reasonable set of problems (~ 10 days / 80 CPU cores).
#Resolutions = [(11,11), (19,17), (23,25), (37,31), (43,41), (83,89)]
# Small problems for the brief testing.
Resolutions = [(13,11), (17,13), (19,15), (23,21), (25,23), (27,25)]

# Integration period in seconds.
IntegrationPeriod = 9000

# Path to the C++ executable.
AMDADOS_EXE = "build/app/amdados"

def WriteParameterFile(conf):
    """ Function writes modified configuration parameters into a new file.
    """
    assert isinstance(conf, Configuration)
    config_file = os.path.join(conf.output_dir, "scalability_test.conf")
    with open(config_file, "wt") as f:
        for attr, val in vars(conf).items():
            f.write("{} {}\n".format(attr, val))
    return config_file


###############################################################################
# Entry point.
###############################################################################
if __name__ == "__main__":
    try:
        # Read configuration file.
        conf = Configuration("amdados.conf")
        # Create the output directory, if it does not exist, and clean it up.
        if not os.path.isdir(conf.output_dir): os.mkdir(conf.output_dir)
        # Check existence of "amdados" application executable.
        assert os.path.isfile(AMDADOS_EXE), "amdados executable was not found"
        # Save some parameters that will be used for visualization.
        params = {"subdomain_x" : int(round(conf.subdomain_x)),
                  "subdomain_y" : int(round(conf.subdomain_y)),
                  "Nschwarz"    : int(round(conf.schwarz_num_iters))}
        np.save(os.path.join(conf.output_dir, "params.npy"), params)

        exe_time_profile = np.zeros((len(Resolutions),2))
        for res_no, res in enumerate(Resolutions):
            # Modify parameters given the current resolution.
            setattr(conf, "num_subdomains_x", int(res[0]))
            setattr(conf, "num_subdomains_y", int(res[1]))
            setattr(conf, "integration_period", int(IntegrationPeriod))
            InitDependentParams(conf)
            conf.PrintParameters()
            config_file = WriteParameterFile(conf)
            subprocess.run("sync", check=True)

            # Python simulator generates the ground-truth and observations.
            Amdados2D(config_file, False)

            # Get the starting time.
            start_time = timer()

            # Run C++ data assimilation application.
            subprocess.run([AMDADOS_EXE, "--scenario", "simulation",
                                "--config", config_file], check=True)

            # Get the execution time and corresponding (global) problem size
            # and save the current scalability profile into the file.
            exe_time_profile[res_no,0] = timer() - start_time
            exe_time_profile[res_no,1] = (
                    conf.num_subdomains_x * conf.subdomain_x *
                    conf.num_subdomains_y * conf.subdomain_y)
            np.savetxt(os.path.join(conf.output_dir, "scalability.txt"),
                       exe_time_profile)

    except subprocess.CalledProcessError as error:
        traceback.print_exc()
        if error.output is not None:
            print("ERROR: " + str(error.output))
        else:
            print("CalledProcessError")
    except AssertionError as error:
        traceback.print_exc()
        print("ERROR: " + str(error.args))
    except ValueError as error:
        traceback.print_exc()
        print("ERROR: " + str(error.args))
    except Exception as error:
        traceback.print_exc()
        print("ERROR: " + str(error.args))

