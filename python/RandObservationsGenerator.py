# -----------------------------------------------------------------------------
# Author    : Albert Akhriev, albert_akhriev@ie.ibm.com
# Copyright : IBM Research Ireland, 2017-2018
# -----------------------------------------------------------------------------

import sys, traceback, os, re, getopt, math, argparse, subprocess
import numpy as np
from timeit import default_timer as timer
from Configuration import Configuration
from Utility import *

# Full-path name of C++ executable.
AMDADOS_EXE =  os.path.join(os.getcwd(),"targetcode/amdados_cc")



def Amdados2D_quick(config_file, demo):
    """ Advection-diffusion PDE forward solver.
    """
    # Initialize parameters, global indices and output directory.
    conf = Configuration(config_file)
    conf = InitDependentParams(conf)
    glo_idx = GlobalIndices(conf)
    if demo: conf.PrintParameters()
    MakePath(conf.output_dir + os.sep)

    # Load sensor locations previously generated by C++ 'amdados' application:
    #   './build/app/amdados --scenario sensors'
    # If does not exist, the file of sensor locations will be regenerated.
    sensors_filename = MakeFileName(conf, "sensors")
    if not os.path.exists(sensors_filename):
        print("")
        print("")
        print("WARNING: missed file of sensor locations: " + sensors_filename)
        print("generating a new one ...")
        assert os.path.exists(AMDADOS_EXE), (
            "Application 'amdados' must be built before running this script")
        amdados = subprocess.Popen(["aprun", "-n", "1", AMDADOS_EXE, "--scenario", "sensors",
                        "--config", config_file])
        amdados.wait()
        print("")
        print("")
    sensor_idx = LoadSensorLocations(conf)

    Nt = round(conf.Nt)
    writer = Writer(conf)
    for k in range(Nt):
        # Write the field entries at sensors into the file of observations from random number
        writer.WriteField(sensor_idx, k)

    # Run forward simulation and record the "true" solutions into a file.
 #   with open(MakeFileName(conf, "true_field"), "wb") as fid:
 #       ForwardSolver(conf, glo_idx, sensor_idx, fid, demo)


###############################################################################
# Initialization.
###############################################################################

def InitDependentParams(conf):
    """ Function initializes dependent parameters given
        the primary ones specified by user.
    """
    # Ensure integer values.
    conf.nx = round(conf.num_subdomains_x * conf.subdomain_x)
    conf.ny = round(conf.num_subdomains_y * conf.subdomain_y)
    conf.integration_nsteps = round(conf.integration_nsteps)

    # Diffusion coefficient must be positive float value.
    D = float(conf.diffusion_coef)
    assert D > 0

    # Deduce space discretization steps.
    conf.problem_size = int(conf.nx * conf.ny)
    dx = float(conf.domain_size_x) / float(conf.nx-1)
    dy = float(conf.domain_size_y) / float(conf.ny-1)
    assert (dx > 0) and (dy > 0)
    conf.dx = dx
    conf.dy = dy

    # Deduce the optimal time step from the stability criteria.
    tiny = np.finfo(float).tiny / np.finfo(float).eps**3
    dt_base = float(conf.integration_period) / float(conf.integration_nsteps)
    max_vx = float(conf.flow_model_max_vx)
    max_vy = float(conf.flow_model_max_vy)
    dt = min(dt_base, min( min(dx**2, dy**2)/(2.0*D + tiny),
                           1.0/(abs(max_vx)/dx + abs(max_vy)/dy + tiny) ))
    assert(dt > 0)
    conf.dt = dt
    conf.Nt = round(math.ceil(float(conf.integration_period) / dt))

    # Compute coefficients that will be used in the finite-difference scheme.
    conf.rho_x = float(D * dt / dx**2)
    conf.rho_y = float(D * dt / dy**2)

    conf.v0x = float(2.0 * dx / dt)
    conf.v0y = float(2.0 * dy / dt)
    return conf


def GlobalIndices(conf):
    """ Each nodal point gets a unique global index on the grid.
        Function initializes a 2D array of indices:
            index of (x,y) = glo_idx(x,y).
    """
    glo_idx = np.arange(round(conf.problem_size)).reshape((conf.nx, conf.ny))
    return glo_idx


def LoadSensorLocations(conf):
    """ Function loads sensor locations, i.e. indices of domain
        points occupied by sensors.
    """
    print("Loading sensor locations ...")
    Nx = conf.nx
    Ny = conf.ny
    Np = round(math.ceil(Nx * Ny * conf.sensor_fraction))
    data = np.loadtxt(MakeFileName(conf, "sensors"), dtype=int)
    assert (data is not None) and (data.size > 0), "empty file of sensors"
    assert len(data.shape) == 2 and data.shape[1] == 2, "wrong layout"
    assert data.shape[0] <= Nx * Ny, "too many records"
    assert data.dtype == int, "type mismatch"
    assert np.all(data >= 0), "negative index"
    assert np.all(data[:,0] < Nx), "x-index is out of bound"
    assert np.all(data[:,1] < Ny), "y-index is out of bound"
    return data

###############################################################################
# Utilities.
###############################################################################

class Writer:
    """ Class for writing simulated solution at sensor locations in a text file.
    """
    def __init__(self, conf):
        """ Constructor. TODO: could be useful to add a header to file:
        """
        # N O T E: np.savetxt() expects (!?) file opened in binary format "wb".
        self.fid = open(MakeFileName(conf, "analytic"), "wb")

    def __del__(self):
        """ This method is not a destructor, but a normal method that is always
            called before the garbage collector destroys the object.
        https://stackoverflow.com/questions/37852560/is-del-really-a-destructor
        """
        if self.fid is not None:
            self.fid.flush()
            self.fid.close()
            self.fid = None

    def WriteField(self, sensor_idx, discrete_time):
        """ Function appends the new field to the output file.
            Only values at sensor locations are written.
            column 1: discrete time;
            column 2: sensor abscissas (point indices) on the grid;
            column 3: sensor ordinates (point indices) on the grid;
            column 4: values at sensor locations.
        """
        assert isinstance(discrete_time, int) and discrete_time >= 0
        assert len(sensor_idx.shape) == 2 and sensor_idx.shape[1] == 2

        xind = sensor_idx[:, 0].astype(int)
        yind = sensor_idx[:, 1].astype(int)
        # For the purpose of performance analysis just set vals as random number
        vals = np.random.rand(len(xind)).astype(float)
        assert np.isnan(vals).any() == False, "NaN in observations"
        vals[np.fabs(vals) <= np.finfo(np.float64).eps]=0
        data = np.column_stack((xind, yind, vals))
        num = data.shape[0]
        np.savetxt(self.fid, np.array([discrete_time, num]), fmt="%d")
        np.savetxt(self.fid, data, fmt="%d %d %g");

###############################################################################
# Entry point.
###############################################################################
if __name__ == "__main__":
    try:
      #  CheckPythonVersion()
        parser = argparse.ArgumentParser()
        parser.add_argument("--config",
                            type=str, default="amdados.conf",
                            help="path to configuration file")
        parser.add_argument("--demo", nargs="?", const=True,
                            type=bool, default=False,
                            help="show live progress in a window")
        param = parser.parse_args()
        param.config = os.path.expanduser(param.config)
        print("Options:")
        print("Visualization: " + str(param.demo))
        print("Configuration files: " + param.config)
        print("")
        Amdados2D(param.config, param.demo)

    except subprocess.CalledProcessError as error:
        traceback.print_exc()
        if error.output is not None:
            print("ERROR: " + str(error.output))
        else:
            print("CalledProcessError")
    except AssertionError as error:
        traceback.print_exc()
        print("ERROR: " + str(error.args))
    except ValueError as error:
        traceback.print_exc()
        print("ERROR: " + str(error.args))
    except Exception as error:
        traceback.print_exc()
        print("ERROR: " + str(error.args))
