// Fearghal wrote:
// Components to be included
// 1) Grid structures specific to each subdomain
//    Each grid structure contains information
//    a) structures for three different layers of resolution:
//       (100m (1) ; 20m(2); 4m(3))
//    b) Solution on each layer
//
// 2) Mechanism to switch from layers 1, 2 & 3
// 3) Advection diffusion solver translated from api-prototype
//  ) Boundary synchronizations translated from api
//    Iterative check on error convergence across each subdomain
//    until error norm of all 4 boundaries < threshold
// 4) Data assimilation structures translated from api-prototype
// 5) Matrix operation structures for DA
// 6) Data assimilation solution
// 7) File reads for initial conditions (simple ascii format)
// 8) File reads for flow fields and observation data
//    (larger files in structured format)

// Model Initialization & file read
// Create structures here for read from file following variables:
// Ndom, nelems;

// Data structures initialization for grid, advection diffusion and DA

// Advection diffusion solution
// Data assimilation check on observation
// Switch to appropriate grid resolution
// Data assimilation solver
// File output at periodic intervals







1) Check indexing consistency: ReadObservations(), SaveGrid2D() and Sub2Ind

2) Mistake in

//                    for (size_t i1 = 0; i1 < nelems_x; i1++)
//                    {
//                        for(size_t j1 = 0; j1 < nelems_y; j1++)
//                        {
//                            forecast[idx][{i1 * nelems_x + j1}] = res.getLayer<L_100m>()[{i1,j1}];
//                        }
//                    }

????

3) Why stepsize is huge?

4) Time step - how it was selected?

5) Check logic of getModelCovar()

6) Physically meaningfull values are needed.
    a) getModelCovar() we take unit value, one unit of what?
    b) but in Euler discrete model space step = 100? 100 of what?

7) Comment in GetModelCovar():
what does it mean: Follow same structure as that implemented for Runga Kutta solver

8) In getObservations():
 obsvloc[{i * nx + j}] = obsver[{igl,jgl,timestep}];
 should be i*ny + j ???

9) NELEMS means number of nodal points???

10) InitSolver(), code around forAllActiveNodes(..) was adjusted, explanation?
11) InitSolver(): TODO comment

12) utils::pfor was wrong

13) in "amdados_grid.h" using namespace allscale::api::user;  // Albert commented

14) solver.h:  const auto& cur = A[idx];
               auto& res = A[idx];   <--- B?

15) Different extensions: cc, cxx, cpp

16) Too many nestings in the project structure.
17) namespace "app" should go before "amdados"

18) Can we do reshape without explicit copying?

19) What do the functions mu1() and mu2() stand for?

20) Rather than creating grids of individual entities (e.g. matrices), create
    a grid of solvers.

21) No sub-domain index bound checking!!!
22) (x,y) or (y,x)
23) which coordinate changes first?
24) how to find min or max across the entire domain?


My tasks:
Memo named "Sensor Placement"


//////////////////////////////////////////////////////////////////////////////////////
Questions:
1) Rationale for design?
2) How to access the grid data, how to traverse it? Can we get grid sizes?
   Can we traverse rows, columns, all elements?
   What is active element?
3) Who is the fastest - x or y?
4) How to get grid sizes?
5) How to declare data in MPI-friendly way?
(so far, we use initialization suitable for multi-threading only)
6) Mutexes and other sync. objects of the allscale API.
7) We need facilities to print text in the terminal, print warning,
pront into file in some MPI/threading safe way.
8) Memory management for the last matrices.
9) Type consistency: int and size_t are mixed up.
10) Compilation bug in ReadObservations()
11)



New, Jan 2018:
1) assert_true fails
2) allscale::utils::Vector<std::size_t, Dims> getActiveLayerSize() {
            return data.getLayerSize(active_layer);
        }
        must be "const"
3) coarsen/refine are not fully correct

4) ...../adaptive_grid.cc:95:51: error: macro "assert_true" passed 2 arguments, but takes just 1
                     assert_true(cell[{x,y}] == cur);
   but this does work:
                     assert_true((cell[{x,y}] == cur));

5) abort() in LazyAssertion(), I would go for assert(0) from <cassert>







